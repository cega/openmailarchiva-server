/*
 * This file was auto-generated by the Axis C++ Web Service Generator (WSDL2Ws)
 * This file contains Client Stub implementation for remote web service.
 */

#include "MailArchiva.hpp"

#include <axis/AxisWrapperAPI.hpp>
#include <axis/Axis.hpp>

MailArchiva::MailArchiva(const char* pcEndpointUri, AXIS_PROTOCOL_TYPE eProtocol):Stub(pcEndpointUri, eProtocol)
{
	setTransportTimeout(300000);
}

MailArchiva::MailArchiva()
:Stub(" ", APTHTTP1_1)
{
	m_pCall->setEndpointURI("http://127.0.0.1:8080/mailarchiva/services/MailArchiva");
	setTransportTimeout(300000);
}

MailArchiva::~MailArchiva()
{
}


/*Methods corresponding to the web service methods*/

/*
 * This method wrap the service methodgetServerVersion
 */
xsd__string MailArchiva::getServerVersion()
{
	xsd__string Ret = NULL;
	const char* pcCmplxFaultName;
	pcCmplxFaultName = NULL;
	try
	{	if (AXIS_SUCCESS != m_pCall->initialize(CPP_DOC_PROVIDER)) return Ret;
		if (NULL==m_pCall->getTransportProperty("SOAPAction",false))
	{
		m_pCall->setTransportProperty(SOAPACTION_HEADER , "");
	}
	m_pCall->setSOAPVersion(SOAP_VER_1_1);
	m_pCall->setOperation("getServerVersion", "url:MAILARCHIVA");
	includeSecure();
	applyUserPreferences();
	if (AXIS_SUCCESS == m_pCall->invoke())
	{
		if(AXIS_SUCCESS == m_pCall->checkMessage("getServerVersionResponse", "url:MAILARCHIVA"))
		{
			xsd__string pReturn = m_pCall->getElementAsString("getServerVersionReturn", 0);
			if(pReturn)
			{
				Ret = new char[strlen( pReturn) + 1];
				strcpy( Ret, pReturn);
				Axis::AxisDelete( pReturn, XSD_STRING);
			}
		}
	}
	m_pCall->unInitialize();
	return Ret;
	}
	catch(AxisException& e)
	{
		int iExceptionCode = e.getExceptionCode();

		if(AXISC_NODE_VALUE_MISMATCH_EXCEPTION != iExceptionCode)
		{
			m_pCall->unInitialize();
			throw;
		}

		ISoapFault* pSoapFault = (ISoapFault*)
			m_pCall->checkFault("Fault","http://127.0.0.1:8080/mailarchiva/services/MailArchiva" );

		if(pSoapFault)
		{
			const char *detail = pSoapFault->getSimpleFaultDetail();
			bool deleteDetail=false;

			if (NULL==detail || 0==strlen(detail))
			{
				detail=m_pCall->getFaultAsXMLString();
				if (NULL==detail)
				{
					detail="";
				}
				else
				{
					deleteDetail=true;
				}
			}

			OtherFaultException ofe(pSoapFault->getFaultcode(),
				pSoapFault->getFaultstring(), pSoapFault->getFaultactor(),
				detail, iExceptionCode);

			if (deleteDetail && NULL!=detail)
			{
				Axis::AxisDelete( (void *) const_cast<char*>(detail), XSD_STRING);
			}

			m_pCall->unInitialize();
			delete pSoapFault;
			throw ofe;
		}
		else
		{
			m_pCall->unInitialize();
			delete pSoapFault;
			throw;
		}
	}
}


/*
 * This method wrap the service methodstoreMessage
 */
void MailArchiva::storeMessage(xsd__base64Binary Value0)
{
	setTransportTimeout(300000);
	const char* pcCmplxFaultName;
	pcCmplxFaultName = NULL;
	try
	{	if (AXIS_SUCCESS != m_pCall->initialize(CPP_DOC_PROVIDER)) return ;
	if (NULL==m_pCall->getTransportProperty("SOAPAction",false))
	{
		m_pCall->setTransportProperty(SOAPACTION_HEADER , "");
	}
	m_pCall->setSOAPVersion(SOAP_VER_1_1);
	m_pCall->setOperation("storeMessage", "url:MAILARCHIVA");
	includeSecure();
	applyUserPreferences();
	char cPrefixAndParamName0[13];
	sprintf( cPrefixAndParamName0, "%s:in0", m_pCall->getNamespacePrefix("url:MAILARCHIVA"));
	m_pCall->addParameter((void*)&Value0, cPrefixAndParamName0, XSD_BASE64BINARY);
	if (AXIS_SUCCESS == m_pCall->invoke())
	{
		if(AXIS_SUCCESS == m_pCall->checkMessage("storeMessageResponse", "url:MAILARCHIVA"))
		{
			/*not successful*/
		}
	}
	m_pCall->unInitialize();
	}
	catch(AxisException& e)
	{
		int iExceptionCode = e.getExceptionCode();

		if(AXISC_NODE_VALUE_MISMATCH_EXCEPTION != iExceptionCode)
		{
			m_pCall->unInitialize();
			throw;
		}

		ISoapFault* pSoapFault = (ISoapFault*)
			m_pCall->checkFault("Fault","http://127.0.0.1:8080/mailarchiva/services/MailArchiva" );

		if(pSoapFault)
		{
			const char *detail = pSoapFault->getSimpleFaultDetail();
			bool deleteDetail=false;

			if (NULL==detail || 0==strlen(detail))
			{
				detail=m_pCall->getFaultAsXMLString();
				if (NULL==detail)
				{
					detail="";
				}
				else
				{
					deleteDetail=true;
				}
			}

			OtherFaultException ofe(pSoapFault->getFaultcode(),
				pSoapFault->getFaultstring(), pSoapFault->getFaultactor(),
				detail, iExceptionCode);

			if (deleteDetail && NULL!=detail)
			{
				Axis::AxisDelete( (void *) const_cast<char*>(detail), XSD_STRING);
			}

			m_pCall->unInitialize();
			delete pSoapFault;
			throw ofe;
		}
		else
		{
			m_pCall->unInitialize();
			delete pSoapFault;
			throw;
		}
	}
}

